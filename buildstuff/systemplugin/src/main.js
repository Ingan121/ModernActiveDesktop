// main.js for ModernActiveDesktop System Plugin
// Made by Ingan121
// Licensed under the MIT License
// SPDX-License-Identifier: MIT

'use strict';

// #region Electron / Node.js Modules
// Modules to control application life and create native browser window
const { app, BrowserView, BrowserWindow, ipcMain, shell, dialog, session, clipboard, systemPreferences, protocol, Menu, Tray } = require('electron');
const path = require('path');
const http = require('http');
const fs = require('fs');
const url = require('url');
const crypto = require('crypto');
const args = require('minimist')(process.argv);
const { spawn, execSync } = require('child_process');
// #endregion

// #region Intro messages
if (!args.metrics) {
  console.log(`ModernActiveDesktop System Plugin ${app.getVersion()}`);
  console.log("Made by Ingan121");
  console.log("Licensed under the MIT License");
  console.log("https://github.com/Ingan121/ModernActiveDesktop/tree/master/buildstuff/systemplugin\n");
}
if (args.help) {
  console.log("Usage: MADSysPlug.exe [options]");
  console.log("--open: Open a URL on startup");
  console.log("--maximize: Maximize the window on startup");
  console.log("--showui: Show the main UI on startup");
  console.log("--port: Port to listen on (default: 3031)");
  console.log("--listen: IP address to listen on (default: 127.0.0.1)");
  console.log("--cors: CORS origin to allow (default: https://madesktop.ingan121.com)");
  console.log("--ignore-token: Don't check for a token in the request");
  console.log("--spotify: Custom Spotify Client ID for Spotify API integration");
  console.log("--spotify-callback-url: Custom Spotify callback URL for Spotify API integration");
  console.log("--spotify-aux-port: Custom port for Spotify API callback");
  console.log("--no-smtc: Disable System Media Transport Controls and use WM_APPCOMMAND / media keys for media control");
  console.log("--metrics: Get window metrics (border size, title height), for internal use only");
  console.log("--help: Show this help message\n");
  console.log("Warning: Using --cors=*, --listen=0.0.0.0, or --ignore-token is considered insecure. Please use these options only for testing.\n");
  process.exit();
}

if (!args.spotify && (args['spotify-callback-url'] || args['spotify-aux-port'])) {
  console.error("Error: spotify-callback-url and spotify-aux-port require a custom Spotify Client ID.");
  process.exit();
}
// #endregion

// #region Constants and Variables
const port = args.port || 3031;
const gotTheLock = !!args.metrics || app.requestSingleInstanceLock();
let tray = null;
let mainWindow = null;
let inputPanel = null;
let mcc = null;
let pendingRes = null;
let ignoreToken = args['ignore-token'];
let denyUnknown = false;
let smtcUnavailable = args['smtc'] === false;
let lastMediaControl = null;

// Spotify API
// Only for fetching currently playing track in MADVis Lyrics, to comply with Spotify's ToS and design guidelines
const spotifyClientId = args.spotify || '98a0e605349f416bbac718ce4d3c30c2';
const spotifyAuxPort = args['spotify-aux-port'];
const spotifyCallbackUrl = args['spotify-callback-url'] || `http://localhost:${port}/spotify/callback`;
let spotifyCodeVerifier = null;
let spotifyCsrfToken = null;
let spotifyPendingRes = null;
let spotifyTimeout = null;

const metrics = {
  // Windows 10 default metrics
  borderSize: 8,
  titleHeight: 22
};

const tempFilePath = app.getPath('temp') + '/madsp-uploaded.dat';
const tokenPath = path.join(__dirname, '../../../madsp-token.txt');
const wpeCheckPath = path.join(__dirname, '../../../js/DeskSettings.js'); // Check if this MADSysPlug is bundled with the WPE Workshop distribution
const isWpeDist = fs.existsSync(wpeCheckPath);
let token = null;
// #endregion

// #region System plugin access control
if (!ignoreToken && isWpeDist) {
  if (!fs.existsSync(tokenPath)) {
    token = crypto.randomBytes(16).toString('hex');
    fs.writeFileSync(tokenPath, token + '\r\n; This token is used to limit the system plugin access to ModernActiveDesktop. Other wallpapers can\'t access the plugin without this token.\r\n; This file is auto-generated by ModernActiveDesktop System Plugin.');
  } else {
    token = fs.readFileSync(tokenPath, 'utf8').split('\r\n')[0];
  }
} else {
  // Disable token verification for non-WPE distributions
  ignoreToken = true;
}

const spAccessConfirmMsg = `This allows the wallpaper to do the following:
  * Open URLs with the default browser
  * Control media playback
  * Get clipboard contents
  * Receive input from the user
  * Save files to the disk (an file picker will be shown)
  * Get system color scheme

Your choice will be remembered until the plugin is restarted. If you don't know what this is, click "No".
(Use --ignore-token to disable this prompt.)`;

const spAccessConfirmOptions = {
  title: 'ModernActiveDesktop System Plugin',
  message: 'An unknown wallpaper is trying to access ModernActiveDesktop System Plugin. Do you want to allow it?',
  type: 'question',
  buttons: ['Yes', 'No'],
  detail: spAccessConfirmMsg
};
// #endregion

// #region Electron window creation and event handling
function createWindow () {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 640,
    height: 200,
    icon: process.platform === 'win32' ? path.join(__dirname, 'icon.ico') : null,
    show: false
  });

  if (args.cors === "*") {
    showErrorMsg(null, "WARNING: You're running ModernActiveDesktop System Plugin with a wildcard CORS option. This is considered insecure, as any webpage can access your system with this plugin. Please only use this option for testing.", "warning");
  }
  if (args.listen === "0.0.0.0") {
    showErrorMsg(null, "WARNING: You're running ModernActiveDesktop System Plugin with a listen option to allow any remote access. This is considered insecure, as anyone on your network can access your system with this plugin. NEVER USE THIS OPTION if your device is connected directly to internet (i.e. you aren't using a router.)", "warning");
  }

  // and load the index.html of the app.
  mainWindow.loadURL(path.join(__dirname, 'index.html'));

  mainWindow.webContents.on('did-finish-load', () => {
    if (args.metrics) {
      const borderSize = (mainWindow.getSize()[0] - mainWindow.getContentSize()[0]) / 2;
      const titleHeight = mainWindow.getSize()[1] - mainWindow.getContentSize()[1] - borderSize * 2 - 1;
      console.log(borderSize, titleHeight);
      app.quit();
      return;
    }

    if (args.showui) {
      mainWindow.show();
    }
  });

  mainWindow.on('close', () => {
    app.quit();
  });

  systemPreferences.on('accent-color-changed', () => {
    mainWindow.webContents.reload();
  });

  systemPreferences.on('color-changed', () => {
    getMetrics();
    mainWindow.webContents.reload();
  });
}

if (!gotTheLock) {
  console.log("ModernActiveDesktop System Plugin is already running. Exiting...");
  app.exit();
} else {
  app.on('second-instance', (event, commandLine, workingDirectory) => {
    // Someone tried to run a second instance, we should focus our window.
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  })

  // This method will be called when Electron has finished
  // initialization and is ready to create browser windows.
  // Some APIs can only be used after this event occurs.
  app.on('ready', function () {
    createWindow();

    if (!args.metrics) {
      getMetrics();
    } else {
      return;
    }

    tray = new Tray(path.join(__dirname, 'icon.ico'));
    const contextMenu = Menu.buildFromTemplate([
      { label: 'Exit', type: 'normal', click: () => { app.exit(); } }
    ])
    tray.setToolTip(`ModernActiveDesktop System Plugin ${app.getVersion()}`);
    tray.setContextMenu(contextMenu);
    
    app.on('activate', function () {
      // On macOS it's common to re-create a window in the app when the
      // dock icon is clicked and there are no other windows open.
      if (BrowserWindow.getAllWindows().length === 0) createWindow();
    });

    ipcMain.on('inputmsg', (event, message) => {
      if (!inputPanel || inputPanel.isDestroyed()) {
        return;
      }
      if (message === 'CompModeOn') {
        inputPanel.center();
      }
    });

    console.log('ModernActiveDesktop System Plugin is ready');
  })
}

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', function () {
  if (process.platform !== 'darwin') app.quit()
})
// #endregion

// #region Helper functions
function showErrorMsg(win, msg, type) {
  const options = {
    message: msg,
    type: type,
    title: 'ModernActiveDesktop System Plugin',
    buttons: ['OK'],
    noLink: true
  }
  dialog.showMessageBox(win, options);
}

function getMetrics() {
  if (process.platform === 'win32') {
    // DPI unaware mode is required to get the correct window metrics in 100% DPI (as MAD operates in virtual pixels)
    // Electron / Chromium also operates in virtual pixels, but its pretty inaccurate regarding window sizes
    process.env.__COMPAT_LAYER = "DPIUNAWARE";
    const result = execSync(`"${process.execPath}" "${__filename}" --metrics`).toString();
    process.env.__COMPAT_LAYER = undefined;
    const [ borderSize, titleHeight ] = result.split(' ').map(Number);
    console.log({ borderSize, titleHeight });
    metrics.borderSize = borderSize;
    metrics.titleHeight = titleHeight;
  }
}

function generateCssScheme() {
  const accent = '#' + systemPreferences.getAccentColor();

  let schemeStyle = '';
  if (process.platform === 'win32') {
    schemeStyle = 
      `:root {
        --active-border: ${systemPreferences.getColor('active-border')};
        --active-title: ${systemPreferences.getColor('active-caption')};
        --app-workspace: ${systemPreferences.getColor('app-workspace')};
        --background: ${systemPreferences.getColor('desktop')};
        --button-alternate-face: ${getButtonAlternateFace()};
        --button-dk-shadow: ${systemPreferences.getColor('3d-dark-shadow')};
        --button-face: ${systemPreferences.getColor('3d-face')};
        --button-hilight: ${systemPreferences.getColor('3d-highlight')};
        --button-light: ${systemPreferences.getColor('3d-light')};
        --button-shadow: ${systemPreferences.getColor('3d-shadow')};
        --button-text: ${systemPreferences.getColor('button-text')};
        --gradient-active-title: ${systemPreferences.getColor('active-caption-gradient')};
        --gradient-inactive-title: ${systemPreferences.getColor('inactive-caption-gradient')};
        --gray-text: ${systemPreferences.getColor('disabled-text')};
        --hilight: ${systemPreferences.getColor('highlight')};
        --hilight-text: ${systemPreferences.getColor('highlight-text')};
        --hot-tracking-color: ${systemPreferences.getColor('hotlight')};
        --inactive-border: ${systemPreferences.getColor('inactive-border')};
        --inactive-title: ${systemPreferences.getColor('inactive-caption')};
        --inactive-title-text: ${systemPreferences.getColor('inactive-caption-text')};
        --info-text: ${systemPreferences.getColor('info-text')};
        --info-window: ${systemPreferences.getColor('info-background')};
        --menu: ${systemPreferences.getColor('menu')};
        --menu-bar: ${systemPreferences.getColor('menubar')};
        --menu-hilight: ${systemPreferences.getColor('menu-highlight')};
        --menu-text: ${systemPreferences.getColor('menu-text')};
        --scrollbar: ${systemPreferences.getColor('scrollbar')};
        --title-text: ${systemPreferences.getColor('caption-text')};
        --window: ${systemPreferences.getColor('window')};
        --window-frame: ${systemPreferences.getColor('window-frame')};
        --window-text: ${systemPreferences.getColor('window-text')};
        --accent: ${accent};
        --accent-dark: ${shadeColor(accent.substring(0, 6), -27)};
        --ui-font: "Segoe UI", "SegoeUI", "Noto Sans", sans-serif;
      }
      .window {
        --extra-border-size: ${metrics.borderSize - 3}px;
        --extra-title-height: ${metrics.titleHeight - 20}px;
      }`;
  } else {
    schemeStyle = 
      `:root {
        --accent: ${accent};
        --accent-dark: ${shadeColor(accent.substring(0, 6), -27)};
      }`;
  }
  return schemeStyle;
}

// idk why but button-alternate-face is not supported by Electron
function getButtonAlternateFace() {
  if (process.platform === 'win32') {
    const output = execSync('reg query "HKCU\\Control Panel\\Colors" /v ButtonAlternateFace').toString();
    return `rgb(${output.match(/REG_SZ    (.*)\r\n/)[1].replaceAll(' ', ', ')})`;
  } else {
    return '#000000';
  }
}

// https://stackoverflow.com/a/13532993
function shadeColor(color, percent) {
  var R = parseInt(color.substring(1,3),16);
  var G = parseInt(color.substring(3,5),16);
  var B = parseInt(color.substring(5,7),16);

  R = parseInt(R * (100 + percent) / 100);
  G = parseInt(G * (100 + percent) / 100);
  B = parseInt(B * (100 + percent) / 100);

  R = (R<255)?R:255;  
  G = (G<255)?G:255;  
  B = (B<255)?B:255;  

  var RR = ((R.toString(16).length===1)?"0"+R.toString(16):R.toString(16));
  var GG = ((G.toString(16).length===1)?"0"+G.toString(16):G.toString(16));
  var BB = ((B.toString(16).length===1)?"0"+B.toString(16):B.toString(16));

  return "#"+RR+GG+BB;
}
// #endregion

// #region Web server
if (!args.metrics) {
  http.createServer(onRequest).listen(port, args.listen || '127.0.0.1');
  console.log('ModernActiveDesktop System Plugin listening on port', port);
}

if (spotifyAuxPort) {
  http.createServer(spotifyCallback).listen(spotifyAuxPort, '127.0.0.1');
  console.log('Auxiliary Spotify callback server listening on port', spotifyAuxPort);
}
console.log('');

async function onRequest(req, res) {
  console.log('serve: ' + req.url);
  const cors = args.cors || 'https://madesktop.ingan121.com';
  res.setHeader('Access-Control-Allow-Origin', cors);
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-Use-ChannelViewer, X-Fullscreen, X-Format-Name, X-Format-Extension, X-MADSP-Token, X-No-Timeout, X-File-Name, X-File-Path, X-MAD-Version');

  let extraVerified = false;

  if (req.headers.origin && req.headers.origin !== 'null') {
    console.log('Origin: ' + req.headers.origin);
    // Allow CORS for special origins
    if (new URL(req.headers.origin).hostname.match(/^(localhost|127(.[0-9]{1,3}){3})$/) || // localhost
      req.headers.origin.startsWith('localfolder://') || // Lively Wallpaper
      req.headers.origin.startsWith('file://')) // Wallpaper Engine 2.4 and below, and MAD running as a local file in browsers (--allow-file-access-from-files in Chromium)
    {
      res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
    } else if (args.cors !== "*" && req.headers.origin !== cors) {
      // Abort if CORS is not allowed
      // This is to prevent arbitrary website from accessing your system
      // Request can proceed even if CORS is not allowed
      // (JS can't get the response but system changes like MediaControl will still be made)
      // So explicitly abort the request if CORS is not allowed
      res.writeHead(403);
      res.end('403 Forbidden', 'utf-8');
      return;
    }
  }
  if (!ignoreToken && req.url !== '/getinput') {
    // Bypass token check for getinput as EventSource doesn't support headers
    // (and it's requires a /begininput request to be made first)
    if (req.headers.origin === 'null' || req.headers.origin === 'file://') {
      // Verify token for requests from Wallpaper Engine
      const tokenHeader = req.headers['x-madsp-token'];
      if (!tokenHeader || tokenHeader !== token) {
        if (denyUnknown || dialog.showMessageBoxSync(null, spAccessConfirmOptions) === 1) {
          denyUnknown = true;
          res.writeHead(403);
          res.end('403 Forbidden', 'utf-8');
          return;
        } else {
          ignoreToken = true;
        }
      } else {
        extraVerified = true;
      }
    }
  }

  if (req.method === 'OPTIONS') {
    res.end();
    return;
  }

  const urlParsed = new URL(req.url, `http://${req.headers.host}`);
  switch (urlParsed.pathname) {
    // Open a URL in the default browser
    // Usage: POST /open with a URL in the request body
    case '/open':
      if (req.method === 'POST') {
        let body = await processPost(req);
        // Handle opening local MAD files
        if (!body.startsWith('http') && !body.startsWith('file') && isWpeDist) {
          body = url.pathToFileURL(path.normalize(`${__dirname}/../../../${body}`)).toString();
        }
        // Deny opening non-HTML local files (or every local file if not a WPE distribution)
        if (body.startsWith('file') &&
          (![".html", ".htm", ".txt"].some(ext => body.toLowerCase().endsWith(ext)) || !isWpeDist)
        ) {
          res.writeHead(403);
          res.end('403 Forbidden', 'utf-8');
          return;
        }
        try {
          // Final URL validation (invalid URLs starting with http or file somehow opens This PC. Other invalid URLs show Electron error dialog if not handled)
          shell.openExternal(new URL(body).toString());
          res.end('OK');
        } catch (e) {
          res.writeHead(500, {'Content-Type':'text/plain'});
          res.end(e.toString(), 'utf-8');
        }
      } else {
        res.writeHead(405, {'Content-Type': 'text/html'});
        res.end('<h1>405 Method Not Allowed</h1><p>Usage: send a POST request with a URL in the request body</p>')
      }
      break;

    // Open a folder in the file explorer
    // Usage: POST /openfolder with a folder name (app.getPath value) in the request body
    case '/openfolder':
      if (req.method === 'POST') {
        try {
          let body = await processPost(req);
          shell.openPath(app.getPath(body));
          res.end('OK');
        } catch (e) {
          res.writeHead(500, {'Content-Type': 'text/plain'});
          res.end(e.toString(), 'utf-8');
        }
      } else {
        res.writeHead(405, {'Content-Type': 'text/html'});
        res.end('<h1>405 Method Not Allowed</h1><p>Usage: send a POST request with a folder name in the request body. Folder name must be a value supported by Electron\'s app.getPath</p>')
      }
      break;

    // Save a file to the disk
    // Usage: POST /save with a file in the request body
    // X-File-Name and X-File-Path can be set to specify the file name and path in the file picker (X-File-Path must be a value supported by Electron's app.getPath)
    // X-Format-Name and X-Format-Extension can be set to specify the file format in the file picker
    case '/save':
      if (req.method === 'POST') {
        try {
          const stream = fs.createWriteStream(tempFilePath);
          req.pipe(stream);
          stream.on('finish', () => {
            const options = {
              defaultPath : path.join(app.getPath(req.headers['x-file-path'] || 'downloads'), (decodeURIComponent(req.headers['x-file-name'] || ''))),
              filters : [
                  {name: req.headers['x-format-name'], extensions: req.headers['x-format-extension'].split(',')},
                  {name: 'All Files', extensions: ['*']}
              ]
            };
            console.log(req.headers);
            const savePath = dialog.showSaveDialogSync(null, options);
            if (!savePath) {
              res.writeHead(500);
              res.end('Aborted');
              return;
            }
            fs.copyFileSync(tempFilePath, savePath);
            fs.unlinkSync(tempFilePath);
            res.end(path.basename(savePath));
          });
        } catch (e) {
          res.writeHead(500);
          res.end(e);
        }
      } else {
        res.writeHead(405, {'Content-Type': 'text/html'});
        res.end('<h1>405 Method Not Allowed</h1><p>Usage: send a POST request with a file in the request body</p>')
      }
      break;

    // Get the system color scheme
    case '/systemscheme':
      res.writeHead(200, {'Content-Type':'text/css'});
      res.end(generateCssScheme());
      break;

    // Get the clipboard contents
    case '/clipboard':
      res.end(clipboard.readText());
      break;

    // Media controls
    case '/play':
    case '/pause':
    case '/playpause':
    case '/stop':
    case '/prev':
    case '/next':
      processMediaControl(req.url, req, res);
      break;

    // MadInput for getting user input in Wallpaper Engine
    case '/begininput':
      cleanInputPanel();
      inputPanel = openInputPanel(req.headers['x-no-timeout']);
      inputPanel.webContents.on('did-finish-load', () => {
        inputPanel.webContents.executeJavaScript('const style=document.createElement("style");style.id="schemeStyle";style.textContent=`'+generateCssScheme()+'`;document.head.appendChild(style);');
        inputPanel.show();
        res.end('OK');
      });
      break;
    
    case '/getinput':
      if (!inputPanel || inputPanel.isDestroyed()) {
        res.writeHead(500);
        res.end('Open /begininput first', 'utf-8');
        return;
      }

      // long polling
      res.writeHead(200, {'Content-Type':'text/event-stream'});
      ipcMain.once('input', (event, message) => {
        pendingRes = null;
        res.end(`data: ${message}\n\n`);
      });
      pendingRes = res;
      break;

    case '/focusinput':
      if (!inputPanel || inputPanel.isDestroyed()) {
        res.writeHead(500);
        res.end('Open /begininput first', 'utf-8');
        return;
      }
      inputPanel.minimize();
      inputPanel.restore();
      inputPanel.focus();
      res.end('OK');
      break;

    case '/endinput':
      cleanInputPanel();
      res.end('OK');
      break;

    // Authorization Code with PKCE Flow
    // https://developer.spotify.com/documentation/web-api/tutorials/code-pkce-flow
    case '/spotify/auth':
      if (args.port && args.port !== 3031 && !args.spotify) {
        res.writeHead(500, {'Content-Type':'application/json'});
        res.end('{"error":"Custom port is not supported with the default Spotify Client ID!"}');
        return;
      }
      spotifyCodeVerifier = crypto.randomBytes(64).toString('hex');
      console.log('Spotify Code Verifier:', spotifyCodeVerifier);
      const codeChallenge = crypto.createHash('sha256').update(spotifyCodeVerifier).digest('base64').replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
      spotifyCsrfToken = crypto.randomBytes(16).toString('base64');

      const authUrl = new URL('https://accounts.spotify.com/authorize');
      const authParams = {
        client_id: spotifyClientId,
        response_type: 'code',
        redirect_uri: spotifyCallbackUrl,
        code_challenge_method: 'S256',
        code_challenge: codeChallenge,
        state: spotifyCsrfToken,
        scope: 'user-read-playback-state'
      };
      authUrl.search = new URLSearchParams(authParams).toString();

      shell.openExternal(authUrl.toString());
      spotifyPendingRes = res;

      spotifyTimeout = setTimeout(() => {
        if (spotifyPendingRes) {
          spotifyPendingRes.writeHead(500, {'Content-Type':'application/json'});
          spotifyPendingRes.end('{"error":"Timeout"}');
          spotifyPendingRes = null;
        }
      }, 180000); // 3 minutes
      break;

    // Spotify auth callback
    case '/spotify/callback':
      spotifyCallback(req, res);
      break;
    
    // Update the system plugin
    // (Not used yet, for future use after 3.5)
    case '/update':
      if (!extraVerified && req.headers.origin) {
        // Mandate token verification for /update (except for non-AJAX requests/direct access from browsers by the user)
        // Only for WPE Workshop distributions
        res.writeHead(403);
        res.end('403 Forbidden', 'utf-8');
        return;
      }
      const version = req.headers['x-mad-version'];
      let updateConfirmMsg = 'ModernActiveDesktop has been updated. Do you want to update the system plugin as well?';
      if (version) {
        updateConfirmMsg += `\n\nVersion: ${app.getVersion()} -> ${version}`;
      }
      const result = dialog.showMessageBoxSync(null, {
        message: updateConfirmMsg,
        type: 'question',
        title: 'ModernActiveDesktop System Plugin',
        buttons: ['Yes', 'No']
      });

      if (result === 0) {
        res.end('OK');
        const updateScript = path.join(__dirname, '../../../Install System Plugin.bat');
        execSync(`start cmd /c "${updateScript}" 1`);
        app.quit();
      } else {
        res.end('Canceled');
      }
      break;

    // Connection test, returns the version of the plugin
    case '/connecttest':
      res.writeHead(200, {'Content-Type':'text/html'});
      res.end(app.getVersion());
      break;

    case '/debugger':
      res.writeHead(200, {'Content-Type':'text/html'});
      res.end('<span style="font-family:monospace">debugger</span> statement activated (if a node debugger has been attached)');
      debugger;
      break;

    case '/favicon.ico':
      res.writeHead(200, {'Content-Type':'image/vnd.microsoft.icon'});
      res.end(fs.readFileSync(path.join(__dirname, 'icon.ico')));
      break;

    case '/':
      res.writeHead(200, {'Content-Type':'text/html'});
      res.end(`
        <!DOCTYPE html>
          <html>
          <head>
            <title>ModernActiveDesktop System Plugin ${app.getVersion()} Web Interface</title>
            <meta charset="utf-8">
          </head>
          <body>
            <h1>ModernActiveDesktop System Plugin ${app.getVersion()} Web Interface</h1>
            <p>
              Available pages:<br>
              <a href="/open">/open</a><br>
              <a href="/openfolder">/openfolder</a><br>
              <a href="/save">/save</a><br>
              <a href="/systemscheme">/systemscheme</a><br>
              <a href="/clipboard">/clipboard</a><br>
              <br>
              <a href="/play">/play</a><br>
              <a href="/pause">/pause</a><br>
              <a href="/playpause">/playpause</a><br>
              <a href="/stop">/stop</a><br>
              <a href="/prev">/prev</a><br>
              <a href="/next">/next</a><br>
              <br>
              <a href="/begininput">/begininput</a><br>
              <a href="/getinput">/getinput</a><br>
              <a href="/focusinput">/focusinput</a><br>
              <a href="/endinput">/endinput</a><br>
              <br>
              <a href="/spotify/auth">/spotify/auth</a><br>
              <a href="/spotify/callback">/spotify/callback</a><br>
              <br>
              <a href="/update">/update</a><br>
              <a href="/connecttest">/connecttest</a><br>
              <a href="/debugger">/debugger</a>
            </p>
          </body>
        </html>
      `);
      break;

    default:
      res.writeHead(404);
      res.end('404 Not Found', 'utf-8');
  }
}
// #endregion

// #region Web server helper functions
function processPost(req, res, callback) {
  return new Promise((resolve, reject) => {
    let body = '';

    req.on('data', function (data) {
      body += data;

      // Too much POST data, kill the connection!
      // 1e6 === 1 * Math.pow(10, 6) === 1 * 1000000 ~~~ 1MB
      if (body.length > 1e6) {
        req.connection.destroy();
        reject(new Error('POST data too large'));
      }
    });

    req.on('end', function () {
      resolve(body);
      if (callback) {
        callback(body);
      }
      if (res) {
        res.end('OK');
      }
    });
  });
}

function processMediaControl(command, req, res) {
  if (command.startsWith('/')) {
    command = command.substring(1);
  }
  if (req.method === 'POST') {
    processPost(req, res, function (body) {
      runMccCmd(command, body);
    });
  } else {
    runMccCmd(command);
    res.end('OK');
  }
  lastMediaControl = command;
}

function initMcc() {
  mcc = spawn(path.join(__dirname, '../MediaControlCLI.exe'), ['utf8']);
  mcc.stdin.setEncoding('utf-8');
  mcc.stdout.setEncoding('utf-8');
  mcc.stderr.setEncoding('utf-8');
  mcc.stdout.pipe(process.stdout);

  mcc.on('error', (err) => {
    console.error(err);
    mcc = null;
    smtcUnavailable = true;
    if (lastMediaControl) {
      runMccCmd(lastMediaControl);
    }
  });

  mcc.on('exit', (code) => {
    console.log(`Media control helper exited with code ${code}`);
    if (code === 2 || code === 3) {
      smtcUnavailable = true;
      if (lastMediaControl) {
        runMccCmd(lastMediaControl);
      }
    }
    mcc = null;
  });
}

function runMccCmd(command, title = "") {
  if (smtcUnavailable) {
    if (command === "play" || command === "pause") {
      command = "playpause";
    }
    console.log(`Running MediaKeys.exe with command ${command}`);
    spawn(path.join(__dirname, '../MediaKeys.exe'), [command]).on('error', (err) => {
      showErrorMsg(null, "Failed to run media control helper.\n" + err.toString(), "error");
    });
    return;
  }
  const args = command + " " + title;
  console.log(args);
  if (!mcc) {
    initMcc();
  }
  mcc.stdin.write(args + "\n");
}

function openInputPanel(noTimeout) {
  const inputPanel = new BrowserWindow({
    width: 640,
    height: 38,
    x: -1000,
    y: -1000,
    icon: process.platform === 'win32' ? path.join(__dirname, 'icon.ico') : null,
    webPreferences: {
      preload: path.join(__dirname, 'inputpanel.js'),
    },
    show: false,
    frame: false,
    skipTaskbar: true,
    resizable: false
  });

  inputPanel.removeMenu();
  inputPanel.loadURL(path.join(__dirname, 'inputpanel.html') + (noTimeout ? '#notimeout' : ''));

  inputPanel.on('show', () => {
    // Ensure the window is focused when opened
    setTimeout(() => {
      if (inputPanel.isDestroyed()) {
        return;
      }
      inputPanel.minimize();
      inputPanel.restore();
      inputPanel.focus();
    }, 100);
  });

  inputPanel.on('close', () => {
    if (pendingRes) {
      pendingRes.end('data: Escape\n\n');
      pendingRes = null;
    }
  });

  return inputPanel;
}

function cleanInputPanel() {
  if (inputPanel && !inputPanel.isDestroyed()) {
    inputPanel.close();
    inputPanel = null;
    if (pendingRes) {
      pendingRes.end('data: Escape\n\n');
      pendingRes = null;
    }
  }
}

function spotifyCallback(req, res) {
  if (req.headers.origin) {
    res.writeHead(403);
    res.end('This page is not meant to be accessed via AJAX.', 'utf-8');
    return;
  }
  const urlParsed = new URL(req.url, `http://${req.headers.host}`);
  const code = urlParsed.searchParams.get('code');
  const error = urlParsed.searchParams.get('error');
  const state = urlParsed.searchParams.get('state');
  if (!state && !(code || error)) {
    res.writeHead(400);
    res.end('400 Bad Request', 'utf-8');
    // Just ignore this request if it's not a callback
    return;
  }
  if (!spotifyPendingRes) {
    res.writeHead(500);
    res.end('No pending auth request', 'utf-8');
    return;
  }
  if (state !== spotifyCsrfToken) {
    res.writeHead(403);
    res.end('CSRF token mismatch', 'utf-8');
    if (spotifyPendingRes) {
      spotifyPendingRes.writeHead(403, {'Content-Type':'application/json'});
      spotifyPendingRes.end('{"error":"CSRF token mismatch"}');
      spotifyPendingRes = null;
      clearTimeout(spotifyTimeout);
    }
    return;
  }
  if (error) {
    res.writeHead(500);
    res.end('Spotify auth error: ' + error, 'utf-8');
    if (spotifyPendingRes) {
      spotifyPendingRes.writeHead(500, {'Content-Type':'application/json'});
      spotifyPendingRes.end('{"error":"' + error + '"}');
      spotifyPendingRes = null;
      clearTimeout(spotifyTimeout);
    }
    return;
  }
  res.writeHead(200, {'Content-Type':'text/html'});
  res.end('You can now close this tab.<script>window.close()</script>');

  if (spotifyPendingRes) {
    spotifyPendingRes.writeHead(200, {'Content-Type':'application/json'});
    spotifyPendingRes.end(JSON.stringify({
      code,
      verifier: spotifyCodeVerifier,
      clientId: spotifyClientId,
      redirectUri: spotifyCallbackUrl
    }));
    spotifyPendingRes = null;
    clearTimeout(spotifyTimeout);
  }
}
// #endregion